//! Audio playback functionality.
//!
//! Plays the audio based on the state of the sound hardware.

use std::sync::Arc;

use anyhow::{anyhow, Result};
use cpal::traits::{DeviceTrait, HostTrait, StreamTrait};
use cpal::{OutputCallbackInfo, SampleFormat, SampleRate, Stream};
use derivative::Derivative;
use log::*;

use crate::cpu;

use super::SampleBuffer;

/// Outputs PCM audio generated by the sound controller.
#[derive(Derivative)]
#[derivative(Debug)]
pub struct Output {
    /// The audio output stream.
    #[derivative(Debug = "ignore")]
    stream: Stream,

    /// Queued raw emulated PCM audio samples.
    pub sample_buffer: SampleBuffer,
}

impl Output {
    pub fn new() -> Result<Self> {
        let device = cpal::default_host()
            .default_output_device()
            .ok_or_else(|| anyhow!("no audio output devices found"))?;

        let sample_buffer = SampleBuffer::default();

        let config = device
            .supported_output_configs()?
            .filter(|config| config.channels() == 1 && config.sample_format() == SampleFormat::F32)
            .next()
            .map(|config| config.with_sample_rate(SampleRate(44_100))) // TODO: use max?
            .ok_or_else(|| anyhow!("no supported audio output configuration found"))?
            .config();

        info!("initializing audio playback with {:?}", config);

        let skipped_samples = (cpu::FREQUENCY / config.sample_rate.0) as usize;

        let stream_buffer = Arc::clone(&sample_buffer);
        let stream = device.build_output_stream(
            &config,
            move |dst: &mut [f32], _: &OutputCallbackInfo| {
                let mut src = stream_buffer.lock().unwrap();

                // Naive nearest-neighbor downsampling
                for (i, sample) in dst.iter_mut().enumerate() {
                    *sample = *src.get(i * skipped_samples).unwrap_or(&0.0);
                }

                src.clear();
            },
            |err| panic!("{}", err),
        )?;

        stream.play()?;

        Ok(Output {
            stream,
            sample_buffer,
        })
    }
}
